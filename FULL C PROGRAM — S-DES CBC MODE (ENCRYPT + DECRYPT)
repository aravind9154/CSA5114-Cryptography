#include <stdio.h>
#include <stdint.h>

// ------------------ PERMUTATIONS ------------------
int P10[10]  = {3,5,2,7,4,10,1,9,8,6};
int P8[8]    = {6,3,7,4,8,5,10,9};
int IP[8]    = {2,6,3,1,4,8,5,7};
int IP_INV[8]= {4,1,3,5,7,2,8,6};
int EP[8]    = {4,1,2,3,2,3,4,1};
int P4[4]    = {2,4,3,1};

// S-boxes
int S0[4][4] = {
    {1,0,3,2},
    {3,2,1,0},
    {0,2,1,3},
    {3,1,3,2}
};
int S1[4][4] = {
    {0,1,2,3},
    {2,0,1,3},
    {3,0,1,0},
    {2,1,0,3}
};

// ------------------ UTILITY ------------------
uint16_t permute(uint16_t in, int *p, int n)
{
    uint16_t out = 0;
    for(int i=0;i<n;i++)
    {
        out <<= 1;
        out |= (in >> (8 - p[i])) & 1;
    }
    return out;
}

uint16_t left_shift_5(uint16_t x)
{
    uint16_t left = (x >> 5) & 0x1F;
    uint16_t right = x & 0x1F;

    left = ((left << 1) | (left >> 4)) & 0x1F;
    right = ((right << 1) | (right >> 4)) & 0x1F;

    return ((left << 5) | right);
}

// ------------------ KEY GENERATION ------------------
void generate_keys(uint16_t key, uint8_t *K1, uint8_t *K2)
{
    uint16_t P10_key = 0;

    // Apply P10
    for (int i=0; i<10; i++)
    {
        P10_key <<= 1;
        P10_key |= (key >> (10 - P10[i])) & 1;
    }

    // Left shift LS-1
    uint16_t LS1 = left_shift_5(P10_key);

    // Generate K1 with P8
    uint8_t k1 = 0;
    for (int i=0; i<8; i++)
    {
        k1 <<= 1;
        k1 |= (LS1 >> (10 - P8[i])) & 1;
    }

    // Left shift LS-2
    uint16_t LS2 = left_shift_5(left_shift_5(LS1));

    // Generate K2 with P8
    uint8_t k2 = 0;
    for (int i=0; i<8; i++)
    {
        k2 <<= 1;
        k2 |= (LS2 >> (10 - P8[i])) & 1;
    }

    *K1 = k1;
    *K2 = k2;
}

// S-DES fK function
uint8_t fk(uint8_t half, uint8_t subkey)
{
    uint8_t expanded = 0;

    // Apply EP
    for(int i=0;i<8;i++)
    {
        expanded <<= 1;
        expanded |= (half >> (4 - EP[i])) & 1;
    }

    // XOR with subkey
    expanded ^= subkey;

    // Split
    uint8_t left = (expanded >> 4) & 0x0F;
    uint8_t right = expanded & 0x0F;

    // S0 lookup
    int row = ((left & 0x8) >> 2) | (left & 1);
    int col = (left >> 1) & 0x3;
    int s0val = S0[row][col];

    // S1 lookup
    row = ((right & 0x8) >> 2) | (right & 1);
    col = (right >> 1) & 0x3;
    int s1val = S1[row][col];

    uint8_t s_output = (s0val << 2) | s1val;

    // Apply P4
    uint8_t P4_out = 0;
    for(int i=0;i<4;i++)
    {
        P4_out <<= 1;
        P4_out |= (s_output >> (4 - P4[i])) & 1;
    }

    return P4_out;
}

// ------------------ ENCRYPT / DECRYPT ------------------
uint8_t sdes_encrypt_block(uint8_t pt, uint8_t K1, uint8_t K2)
{
    uint8_t temp = permute(pt, IP, 8);
    uint8_t left = (temp >> 4) & 0xF;
    uint8_t right = temp & 0xF;

    // Round 1
    uint8_t f = fk(right, K1);
    left ^= f;

    // Swap
    uint8_t tmp = left;
    left = right;
    right = tmp;

    // Round 2
    f = fk(right, K2);
    left ^= f;

    uint8_t pre_output = (left << 4) | right;
    uint8_t ct = permute(pre_output, IP_INV, 8);

    return ct;
}

uint8_t sdes_decrypt_block(uint8_t ct, uint8_t K1, uint8_t K2)
{
    // same as encryption but keys reversed
    return sdes_encrypt_block(ct, K2, K1);
}

// ------------------ CBC MODE ------------------
void cbc_encrypt(uint8_t *plaintext, uint8_t *ciphertext, int blocks,
                 uint8_t K1, uint8_t K2, uint8_t IV)
{
    uint8_t prev = IV;
    for(int i=0;i<blocks;i++)
    {
        uint8_t x = plaintext[i] ^ prev;
        ciphertext[i] = sdes_encrypt_block(x, K1, K2);
        prev = ciphertext[i];
    }
}

void cbc_decrypt(uint8_t *ciphertext, uint8_t *plaintext, int blocks,
                 uint8_t K1, uint8_t K2, uint8_t IV)
{
    uint8_t prev = IV;
    for(int i=0;i<blocks;i++)
    {
        uint8_t x = sdes_decrypt_block(ciphertext[i], K1, K2);
        plaintext[i] = x ^ prev;
        prev = ciphertext[i];
    }
}

// ------------------ MAIN (TEST) ------------------
int main()
{
    // Given test data
    uint8_t_
