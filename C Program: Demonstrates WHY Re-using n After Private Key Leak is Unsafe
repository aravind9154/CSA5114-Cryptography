#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Function to compute modular inverse using Extended Euclid
long long modInverse(long long a, long long m) {
    long long m0 = m, t, q;
    long long x0 = 0, x1 = 1;

    if (m == 1) return 0;

    while (a > 1) {
        q = a / m;
        t = m;
        m = a % m;
        a = t;

        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0)
        x1 += m0;

    return x1;
}

int main() {
    // Example RSA values
    long long p = 61;
    long long q = 53;
    long long n = p * q;              // modulus
    long long phi = (p - 1) * (q - 1);

    long long e = 17;                 // Public key exponent
    long long d = modInverse(e, phi); // Private key

    printf("=== Original RSA Keys ===\n");
    printf("p = %lld, q = %lld\n", p, q);
    printf("n = %lld\n", n);
    printf("Public key:  (e, n) = (%lld, %lld)\n", e, n);
    printf("Private key: (d, n) = (%lld, %lld)\n\n", d, n);

    printf("Bob leaks his private key d = %lld!\n", d);

    // The attacker now computes Ï†(n)
    long long phi_recovered = e * d - 1;

    // We find k such that phi_recovered / k = phi
    long long k;
    for (k = 1; k < 100; k++) {
        if ((phi_recovered % k) == 0 && 
            (phi_recovered / k) == phi) break;
    }

    phi_recovered /= k;

    printf("\nAttacker computes phi(n) = %lld\n", phi_recovered);

    // Recover p and q from n and phi
    long long s = n - phi_recovered + 1;
    long long D = s * s - 4 * n;
    long long sqrtD = (long long)sqrt(D);

    long long p_rec = (s + sqrtD) / 2;
    long long q_rec = (s - sqrtD) / 2;

    printf("Attacker recovers primes p = %lld, q = %lld\n", p_rec, q_rec);

    printf("\nBob now tries to generate a new e2 and d2 WITHOUT changing n...\n");

    long long e2 = 7;
    long long d2 = modInverse(e2, phi);

    printf("New public key:  (e2, n) = (%lld, %lld)\n", e2, n);
    printf("New private key: (d2, n) = (%lld, %lld)\n", d2, n);

    printf("\n=== SECURITY RESULT ===\n");
    printf("This is NOT SAFE.\n");
    printf("Once p and q are known, ANY new key using the same n can be broken.\n");
    printf("Bob must generate a completely new modulus n = p*q.\n");

    return 0;
}
